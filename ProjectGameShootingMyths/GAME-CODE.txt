1.Menu: 
    -Music (.wav) 
    -Start & Exit
    -Credits

2.Kill Counter
    -Variable/Object that will store and check Bullet_Collision and increase per Collision

3.Game Over Overlay
    -Improve, and stop ingame music.

4.Enemy Drops 
    -Enemies Drops Bullets and Weapons
5.Player Hp Bar
    -Player gets hit 5 Timews before Dying



import pygame 
from os.path import join 
from os import walk 
from pytmx.util_pygame import load_pygame
from random import randint, choice
from math import degrees, atan2 
from collections import deque

# --- SETTINGS / CONSTANTS (from settings.py) ---
WINDOW_WIDTH, WINDOW_HEIGHT = 1280, 720 
TILE_SIZE = 64

# Game States
MENU = 0
GAME_ACTIVE = 1
GAME_OVER = 2

# Menu Colors
MENU_BG_COLOR = (20, 20, 30)
BUTTON_COLOR = 'cyan'

# --- UTILITY GROUPS (from groups.py) ---
class AllSprites(pygame.sprite.Group):
    def __init__(self):
        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.offset = pygame.math.Vector2(0,0)

    # Player Centered Camera
    def draw(self, target_pos):
        # Calculate offset to center on the target (player)
        self.offset.x = -(target_pos[0] - WINDOW_WIDTH // 2)
        self.offset.y = -(target_pos[1] - WINDOW_HEIGHT // 2)

        # Separate sprites into layers for drawing order
        ground_sprites = [sprite for sprite in self if hasattr(sprite, 'ground')]
        object_sprites = [sprite for sprite in self if not hasattr(sprite, 'ground')]

        # Draw ground sprites (floor/map)
        for sprite in ground_sprites:
            self.display_surface.blit(sprite.image, sprite.rect.topleft + self.offset)
        
        # Draw all other sprites (objects, drops, player, gun, enemies, bullets) sorted by Y-position
        for sprite in sorted(object_sprites, key = lambda sprite: sprite.rect.centery):
            self.display_surface.blit(sprite.image, sprite.rect.topleft + self.offset)

# --- SPRITE CLASSES (from sprite.py) ---

class MapSprite(pygame.sprite.Sprite):
    """Base class for map elements like floors and background objects."""
    def __init__(self, pos, surf, groups):
        super().__init__(groups)
        self.image = surf
        self.rect = self.image.get_frect(topleft= pos)
        self.ground = True # Used for layer sorting

class CollisionSprite(pygame.sprite.Sprite):
    """Sprite for map objects that block movement (walls/solid objects)."""
    def __init__(self, pos, surf, groups):
        super().__init__(groups)
        self.image = surf
        self.rect = self.image.get_frect(topleft = pos)

class Drop(pygame.sprite.Sprite):
    """Collectible item drop for health or cooldown reduction."""
    def __init__(self, pos, drop_type, groups):
        super().__init__(groups)
        self.drop_type = drop_type # 'bullet' (cooldown) or 'health'
        
        if drop_type == 'health':
            color = (255, 0, 50)  # Bright Red
            text = 'H'
        else: # 'bullet'
            color = (255, 255, 50) # Bright Yellow
            text = 'B'
            
        self.image = pygame.Surface((30, 30), pygame.SRCALPHA)
        self.image.fill(color)
        self.image.set_colorkey((0,0,0))
        
        # Text overlay
        font = pygame.font.Font(None, 24)
        text_surf = font.render(text, True, 'black')
        text_rect = text_surf.get_rect(center=(15, 15))
        self.image.blit(text_surf, text_rect)
        
        self.rect = self.image.get_frect(center=pos)
        self.lifetime = 10000 # 10 seconds lifetime
        self.spawn_time = pygame.time.get_ticks()

    def update(self, dt):
        # Timer to despawn the drop
        if pygame.time.get_ticks() - self.spawn_time > self.lifetime:
            self.kill()

class Gun(pygame.sprite.Sprite):
    """The player's weapon sprite, follows the player and points at the mouse."""
    def __init__(self, player, groups):
        self.player = player    
        self.distance = 140
        self.player_direction = pygame.Vector2(0, 1)

        super().__init__(groups)
        try:
            self.gun_surf = pygame.image.load(join('images','gun','gun.png')).convert_alpha()
        except pygame.error:
            # Fallback if image not found
            print("Warning: Gun image not found. Using placeholder.")
            self.gun_surf = pygame.Surface((60, 20), pygame.SRCALPHA)
            self.gun_surf.fill('gray')
            
        self.image = self.gun_surf
        self.rect = self.image.get_frect(center = self.player.rect.center + self.player_direction * self.distance)

    def get_direction(self):
        mouse_pos = pygame.mouse.get_pos()
        # Calculate direction vector from player to mouse cursor
        gun_tip_pos = pygame.math.Vector2(self.rect.topleft) + (pygame.math.Vector2(self.image.get_size()) / 2)
        direction_vector = pygame.math.Vector2(mouse_pos) - gun_tip_pos
        
        # Ensure we don't normalize a zero vector
        if direction_vector.magnitude() > 0:
            return direction_vector.normalize(), direction_vector.angle_to(pygame.Vector2(1, 0))
        return pygame.Vector2(1, 0), 0

    def rotate(self, angle):
        # Rotate gun image based on mouse angle
        rotated_image = pygame.transform.rotate(self.gun_surf, angle)
        
        # Adjust position after rotation
        self.image = rotated_image
        self.rect = self.image.get_frect(center = self.rect.center)

    def update(self, dt):
        # Update gun position to follow the player
        center_offset = pygame.math.Vector2(self.player.rect.center)
        self.rect.center = center_offset + self.player_direction * self.distance
        
        # Calculate and apply rotation
        direction, angle = self.get_direction()
        self.player_direction = direction
        self.rotate(-angle) # Pygame rotation is counter-clockwise

class Bullet(pygame.sprite.Sprite):
    """A projectile fired by the player's gun."""
    def __init__(self, pos, direction, groups):
        super().__init__(groups)
        
        self.image = pygame.Surface((15, 15), pygame.SRCALPHA)
        self.image.fill('white')
        self.image.set_colorkey((0,0,0))
        
        self.rect = self.image.get_frect(center = pos)
        self.pos = pygame.math.Vector2(self.rect.center)
        
        self.direction = direction
        self.speed = 1000
        self.bullet_lifetime = 500 # milliseconds
        self.spawn_time = pygame.time.get_ticks()
        
    def update(self, dt):
        # Move bullet
        self.pos += self.direction * self.speed * dt
        self.rect.center = round(self.pos.x), round(self.pos.y)
        
        # Despawn after lifetime
        if pygame.time.get_ticks() - self.spawn_time > self.bullet_lifetime:
            self.kill()

class Enemy(pygame.sprite.Sprite):
    """An enemy sprite that moves toward the player."""
    def __init__(self, pos, frames, groups, player, collision_sprites, speed):
        super().__init__(groups)
        self.is_dead = False
        
        # Graphics and Animation
        self.frames = frames
        self.frame_index = 0
        self.image = self.frames[self.frame_index]
        self.mask = pygame.mask.from_surface(self.image)
        self.animation_speed = 10
        
        # Positioning
        self.rect = self.image.get_frect(center = pos)
        self.hitbox_rect = self.rect.inflate(-60, -60)
        self.pos = pygame.math.Vector2(self.rect.center)
        
        # Movement
        self.direction = pygame.math.Vector2()
        self.speed = speed
        self.player = player
        self.collision_sprites = collision_sprites
        
        # Death Timer
        self.death_time = 0
        self.death_duration = 200 # Flashes after being hit

    def update(self, dt):
        if not self.is_dead:
            self.animate(dt)
            self.move(dt)
        else:
            self.death_timer()

    def animate(self, dt):
        self.frame_index += self.animation_speed * dt
        if self.frame_index >= len(self.frames):
            self.frame_index = 0
        self.image = self.frames[int(self.frame_index)]
        self.mask = pygame.mask.from_surface(self.image)

    def move(self, dt):
        # Get direction towards the player
        player_pos = pygame.math.Vector2(self.player.hitbox_rect.center)
        enemy_pos = pygame.math.Vector2(self.hitbox_rect.center)
        
        # Calculate direction, normalize if magnitude > 0
        if (player_pos - enemy_pos).magnitude() > 0:
            self.direction = (player_pos - enemy_pos).normalize()
        else:
            self.direction = pygame.math.Vector2(0, 0)
        
        # Update position and check collisions
        self.hitbox_rect.x += self.direction.x * self.speed * dt
        self.collisions('horizontal')
        self.hitbox_rect.y += self.direction.y * self.speed * dt
        self.collisions('vertical')
        self.rect.center = self.hitbox_rect.center

    def collisions(self, direction):
        for sprite in self.collision_sprites:
            if sprite.rect.colliderect(self.hitbox_rect):
                # Simple push back on collision
                if direction == 'horizontal':
                    if self.direction.x > 0: self.hitbox_rect.right = sprite.rect.left
                    if self.direction.x < 0: self.hitbox_rect.left = sprite.rect.right
                else:
                    if self.direction.y > 0: self.hitbox_rect.bottom= sprite.rect.top
                    if self.direction.y < 0: self.hitbox_rect.top = sprite.rect.bottom

    def destroy(self):
        """Called when the enemy is hit by a bullet."""
        self.is_dead = True
        self.death_time = pygame.time.get_ticks()
        
        # Visual effect: Turn the enemy sprite white/transparent on hit
        surf = self.image.copy()
        surf.fill((255, 255, 255, 100), special_flags=pygame.BLEND_RGB_MULT)
        self.image = surf

    def death_timer(self):
        """Handles the flash and eventual removal of the dead enemy sprite."""
        if pygame.time.get_ticks() - self.death_time > self.death_duration:
            self.kill()


# --- PLAYER CLASS (from player.py) ---

class Player(pygame.sprite.Sprite):
    def __init__(self, pos, groups, collision_sprites):
        super().__init__(groups)
        self.load_images()
        self.state, self.frame_index = "down", 0
        
        # Initialize with a default image/rect size
        try:
            self.image = self.frames['down'][0]
        except (KeyError, IndexError):
            # Fallback image if asset loading failed
            self.image = pygame.Surface((100, 100), pygame.SRCALPHA)
            self.image.fill('blue')
        
        self.rect = self.image.get_frect(center = pos)
        
        # Movement/Collision
        self.direction = pygame.math.Vector2()
        self.speed = 500
        self.collision_sprites = collision_sprites
        
        # Hitbox (smaller for more forgiving collisions)
        self.hitbox_rect= self.rect.inflate(-90, -90)
        self.mask = pygame.mask.from_surface(self.image)


    def load_images(self):
        """Loads all player animation frames."""
        self.frames= {'left':[], 'right':[], 'up':[], 'down':[]}

        # Walk through player image directories
        for state in self.frames.keys():
            path = join( 'images', 'player', state)
            if not pygame.os.path.exists(path):
                print(f"Warning: Player images not found for state '{state}'. Using placeholder.")
                # Create a placeholder if files are missing
                surf = pygame.Surface((100, 100), pygame.SRCALPHA)
                surf.fill('blue')
                self.frames[state].append(surf)
                continue
                
            for folder_path, sub_folders, file_names in walk(path):
                if file_names:
                    for file_name in sorted(file_names, key= lambda name: int (name.split('.')[0])):
                        full_path = join(folder_path, file_name)
                        try:
                            surf = pygame.image.load(full_path).convert_alpha()
                            self.frames[state].append(surf)
                        except pygame.error as e:
                            print(f"Error loading {full_path}: {e}")
        
    def input(self):
        """Handles keyboard input for movement."""
        keys = pygame.key.get_pressed()
        
        # Y-direction
        if keys[pygame.K_w]:
            self.direction.y = -1
        elif keys[pygame.K_s]:
            self.direction.y = 1
        else:
            self.direction.y = 0
            
        # X-direction
        if keys[pygame.K_d]:
            self.direction.x = 1
        elif keys[pygame.K_a]:
            self.direction.x = -1
        else:
            self.direction.x = 0

    def get_state(self):
        """Determines the current animation state based on direction."""
        if self.direction.magnitude() != 0:
            # Normalize direction for consistent speed
            self.direction = self.direction.normalize() 

            # Horizontal movement overrides vertical for state if both are pressed
            if self.direction.x > 0:
                self.state = 'right'
            elif self.direction.x < 0:
                self.state = 'left'
            elif self.direction.y > 0:
                self.state = 'down'
            elif self.direction.y < 0:
                self.state = 'up'
        # If standing still, keep the last direction state

    def move(self, dt):
        """Applies movement and checks for collisions."""
        # Horizontal movement and collision
        self.hitbox_rect.x += self.direction.x * self.speed * dt
        self.collision('horizontal')
        
        # Vertical movement and collision
        self.hitbox_rect.y += self.direction.y * self.speed * dt
        self.collision('vertical')
        
        # Update visual rect position from the hitbox
        self.rect.center = self.hitbox_rect.center

    def collision(self, direction):
        """Resolves collisions with map sprites."""
        for sprite in self.collision_sprites:
            if sprite.rect.colliderect(self.hitbox_rect):
                if direction == 'horizontal':
                    if self.direction.x > 0: # Moving right
                        self.hitbox_rect.right = sprite.rect.left
                    if self.direction.x < 0: # Moving left
                        self.hitbox_rect.left = sprite.rect.right
                else: # Vertical collision
                    if self.direction.y > 0: # Moving down
                        self.hitbox_rect.bottom= sprite.rect.top
                    if self.direction.y < 0: # Moving up
                        self.hitbox_rect.top = sprite.rect.bottom

    def animate(self, dt):
        """Cycles through animation frames."""
        # If no movement, animation speed is 0
        animation_speed = 10 if self.direction.magnitude() > 0 else 0 

        # Animation logic
        if animation_speed > 0:
            self.frame_index += animation_speed * dt
            if self.frame_index >= len(self.frames[self.state]):
                self.frame_index = 0
            self.image = self.frames[self.state][int(self.frame_index)]
        else:
            # Show the first frame of the current state when idle
            self.frame_index = 0
            self.image = self.frames[self.state][0]
        
        self.mask = pygame.mask.from_surface(self.image)

    def update(self, dt):
        self.input()
        self.get_state()
        self.move(dt)
        self.animate(dt)

# --- MENU CLASS (from main.py snippet) ---

class Menu:
    """The main menu screen handler."""
    def __init__(self, game):
        self.game = game
        self.display_surface = game.display_surface
        self.font = pygame.font.Font(None, 64)
        self.small_font = pygame.font.Font(None, 40)
        
        self.start_text = "START GAME"
        self.credits_text = "CREDITS"
        self.exit_text = "EXIT"

        # Music
        try:
            # Stop existing music (if any was left from a previous game over)
            pygame.mixer.music.stop() 
            pygame.mixer.music.load(join('audio', 'menu_music.wav'))
            pygame.mixer.music.set_volume(0.3)
            pygame.mixer.music.play(-1) # Loop indefinitely
        except pygame.error as e:
            print(f"Warning: Menu music not found or failed to load: {e}")

    def display(self):
        self.display_surface.fill(MENU_BG_COLOR)
        
        # Title
        title_surf = self.font.render("ALAGAD", True, 'white')
        title_rect = title_surf.get_rect(center=(WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 - 150))
        self.display_surface.blit(title_surf, title_rect)

        # Draw Menu Buttons (Simple text-based buttons for now)
        center_x = WINDOW_WIDTH // 2
        
        # Start Button
        self.start_surf = self.small_font.render(self.start_text, True, 'white')
        self.start_rect = self.start_surf.get_rect(center=(center_x, WINDOW_HEIGHT // 2))
        self.draw_button(self.start_surf, self.start_rect)

        # Credits Button
        self.credits_surf = self.small_font.render(self.credits_text, True, 'white')
        self.credits_rect = self.credits_surf.get_rect(center=(center_x, WINDOW_HEIGHT // 2 + 70))
        self.draw_button(self.credits_surf, self.credits_rect)
        
        # Exit Button
        self.exit_surf = self.small_font.render(self.exit_text, True, 'white')
        self.exit_rect = self.exit_surf.get_rect(center=(center_x, WINDOW_HEIGHT // 2 + 140))
        self.draw_button(self.exit_surf, self.exit_rect)

    def draw_button(self, surf, rect):
        """Renders the button text, with a highlight if the mouse is hovering."""
        mouse_pos = pygame.mouse.get_pos()
        color = BUTTON_COLOR if rect.collidepoint(mouse_pos) else 'white'
        
        # Redraw text with color for hover effect
        colored_surf = self.small_font.render(surf.get_text(), True, color)
        self.display_surface.blit(colored_surf, rect)

    def handle_input(self):
        """Checks for mouse click on menu options."""
        mouse_pos = pygame.mouse.get_pos()
        
        if self.start_rect.collidepoint(mouse_pos):
            self.game.state = GAME_ACTIVE
            pygame.mixer.music.stop()
            self.game.setup() # Setup is called here to start the game
        elif self.credits_rect.collidepoint(mouse_pos):
            print("Showing Credits...") # Placeholder
        elif self.exit_rect.collidepoint(mouse_pos):
            self.game.running = False


# --- GAME CLASS (from main.py snippet) ---

class Game:
    """The main game engine and state manager."""
    def __init__(self):
        pygame.init()
        self.display_surface = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("Alagad: Conquest of Philippines Mythical Creatures")
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game State Control
        self.state = MENU 
        self.menu = Menu(self)
        
        # Player Stats
        self.player_max_health = 5
        self.player_health = self.player_max_health
        self.is_vulnerable = True
        self.hit_time = 0
        self.vulnerability_duration = 1000 # 1 second of invulnerability

        # Score and Difficulty Scaling
        self.score = 0
        self.current_enemy_speed = 500
        self.speed_increment = 50
        self.scaling_threshold = 100
        self.base_spawn_interval = 300
        self.spawn_interval_decrement = 20
        self.min_spawn_interval = 100

        # Groups Sprite
        self.all_sprites = AllSprites()
        self.collision_sprites = pygame.sprite.Group()
        self.bullet_sprites = pygame.sprite.Group()
        self.enemy_sprites = pygame.sprite.Group()
        self.drop_sprites = pygame.sprite.Group()
        
        # Asset Loading
        self.load_assets()
        # Setup is called here just to load map/assets immediately before the menu starts
        self.setup(initial=True) 
        
        # Gun timer
        self.can_shoot = True
        self.shoot_time = 0
        self.gun_cooldown = 100 # milliseconds

        # Enemy Timer Event
        self.enemy_event = pygame.event.custom_type()
        pygame.time.set_timer(self.enemy_event, self.base_spawn_interval, 1) # Set to run once to start the loop
        self.spawn_positions = []


    def load_assets(self):
        """Loads enemy animations and audio files."""
        # Load Enemy Frames
        self.enemy_frames = {}
        for folder_path, sub_folders, file_names in walk(join('images', 'enemies')):
            if file_names:
                state = folder_path.split(join('images', 'enemies'))[-1].replace('\\', '/').strip('/')
                self.enemy_frames[state] = []
                for file_name in sorted(file_names, key=lambda name: int(name.split('.')[0])):
                    full_path = join(folder_path, file_name)
                    surf = pygame.image.load(full_path).convert_alpha()
                    self.enemy_frames[state].append(surf)
                    
        # Audios
        try:
            self.shoot_sound = pygame.mixer.Sound(join('audio','shoot.wav'))
            self.shoot_sound.set_volume(0.2)
            self.impact_sound = pygame.mixer.Sound(join('audio','impact.ogg'))
            self.impact_sound.set_volume(0.2)
            self.death_sound = pygame.mixer.Sound(join('audio','death.wav'))
            self.death_sound.set_volume(0.5)
        except pygame.error as e:
            print(f"Warning: Audio files not found or failed to load: {e}")
            # Use placeholder function to prevent crashes if sounds are missing
            self.shoot_sound = self.impact_sound = self.death_sound = lambda: deque().append(0) # Simple way to simulate a sound object

    def setup(self, initial=False):
        """Resets the game state and loads map/sprites."""
        
        # Reset groups
        self.all_sprites.empty()
        self.collision_sprites.empty()
        self.bullet_sprites.empty()
        self.enemy_sprites.empty()
        self.drop_sprites.empty()

        # Reset Player Health and Invulnerability
        self.player_health = self.player_max_health
        self.is_vulnerable = True

        # Load Tiled Map
        try:
            self.tmx_map = load_pygame(join('data', 'philippines_mythical.tmx'))
        except pygame.error as e:
            print(f"Error loading map: {e}. Cannot start game.")
            self.running = False
            return

        # Create Player and Gun
        self.player = Player((500, 500), (self.all_sprites), self.collision_sprites)
        self.gun = Gun(self.player, (self.all_sprites))

        # Build map sprites
        for layer in ['Floor', 'Walls', 'Objects']:
            for x, y, surf in self.tmx_map.get_layer_by_name(layer).tiles():
                pos = (x * TILE_SIZE, y * TILE_SIZE)
                if layer == 'Walls':
                    CollisionSprite(pos, surf, (self.all_sprites, self.collision_sprites))
                else:
                    MapSprite(pos, surf, (self.all_sprites))

        # Get spawn positions
        self.spawn_positions = []
        for obj in self.tmx_map.get_layer_by_name('Spawn'):
            self.spawn_positions.append((obj.x, obj.y))

        # Reset timers and score
        self.score = 0
        self.current_enemy_speed = 500
        self.base_spawn_interval = 300
        self.scaling_threshold = 100
        
        # Reset the enemy timer
        pygame.time.set_timer(self.enemy_event, self.base_spawn_interval)
        
        # Start Game Music if game is starting from menu
        if self.state == GAME_ACTIVE and not initial: 
            try:
                pygame.mixer.music.load(join('audio', 'game_track.wav'))
                pygame.mixer.music.set_volume(0.4)
                pygame.mixer.music.play(-1)
            except pygame.error as e:
                print(f"Warning: Game music not found or failed to load: {e}")


    def gun_timer(self):
        """Handles the gun cooldown."""
        if not self.can_shoot:
            if pygame.time.get_ticks() - self.shoot_time >= self.gun_cooldown:
                self.can_shoot = True

    def vulnerability_timer(self):
        """Handles the player's invulnerability period after being hit."""
        if not self.is_vulnerable:
            # Player flashes during invulnerability (handled in display_ui)
            if pygame.time.get_ticks() - self.hit_time >= self.vulnerability_duration:
                self.is_vulnerable = True

    def input(self):
        """Checks for mouse input to shoot."""
        if self.can_shoot:
            if pygame.mouse.get_pressed()[0]: # Left click
                self.shoot_sound.play()
                direction, _ = self.gun.get_direction()
                Bullet(self.gun.rect.center, direction, (self.all_sprites, self.bullet_sprites))
                self.can_shoot = False
                self.shoot_time = pygame.time.get_ticks()

    def bullet_collision(self):
        """Checks for collisions between bullets and enemies."""
        for bullet in self.bullet_sprites:
            collision_sprites = pygame.sprite.spritecollide(bullet, self.enemy_sprites, False, pygame.sprite.collide_mask)
            
            if collision_sprites:
                self.impact_sound.play()
                for sprite in collision_sprites:
                    if not sprite.is_dead: 
                        sprite.destroy()
                        self.score += 1 
                        
                        # --- ENEMY DROP LOGIC ---
                        if randint(1, 100) < 35: # 35% chance
                            drop_type = choice(['bullet', 'health']) 
                            Drop(sprite.rect.center, drop_type, (self.all_sprites, self.drop_sprites))

                        # Check difficulty scaling condition
                        if self.score >= self.scaling_threshold:
                            self.scale_difficulty()
                            
                bullet.kill()
    
    def drop_collision(self):
        """Checks if player collects drops."""
        drops_collected = pygame.sprite.spritecollide(self.player, self.drop_sprites, True)
        for drop in drops_collected:
            if drop.drop_type == 'bullet':
                # Reduce gun cooldown (faster shooting), minimum 50ms
                self.gun_cooldown = max(50, self.gun_cooldown - 5) 
            elif drop.drop_type == 'health':
                # Restore 1 HP, up to max
                self.player_health = min(self.player_max_health, self.player_health + 1)
    
    def scale_difficulty(self):
        """Increases enemy speed and decreases spawn interval."""
        self.current_enemy_speed += self.speed_increment
        
        # Calculate new spawn interval
        new_interval = max(self.min_spawn_interval, self.base_spawn_interval - self.spawn_interval_decrement)
        
        if new_interval < self.base_spawn_interval:
            self.base_spawn_interval = new_interval
            # Reset the timer with the new, shorter interval
            pygame.time.set_timer(self.enemy_event, self.base_spawn_interval)
            print(f"Spawn interval decreased! New Interval: {self.base_spawn_interval}ms")

        # Set the next threshold for scaling
        self.scaling_threshold += 100
        
        print(f"Difficulty increased! New Enemy Speed: {self.current_enemy_speed}")
    
    def player_collision(self):
        """Checks if the player is hit by an enemy."""
        if self.is_vulnerable and pygame.sprite.spritecollide(self.player, self.enemy_sprites, False, pygame.sprite.collide_mask):
            self.death_sound.play()
            
            self.player_health -= 1 # Decrease health
            self.is_vulnerable = False
            self.hit_time = pygame.time.get_ticks()
            
            if self.player_health <= 0:
                self.game_over()
    
    def game_over(self):
        """Sets the game state to Game Over."""
        self.state = GAME_OVER
        pygame.mixer.music.stop()

    def display_ui(self):
        """Renders the score, stats, and HP bar."""
        font = pygame.font.Font(None, 36)
        
        # Stat Display
        stats_x = 10
        stats_y = 10
        pygame.draw.rect(self.display_surface, (0, 0, 0, 150), (stats_x - 5, stats_y - 5, 250, 130), 0, 10)
        
        score_text = font.render(f"Score: {self.score}", True, 'white') 
        speed_text = font.render(f"Speed: {self.current_enemy_speed}", True, 'red')
        spawn_text = font.render(f"Spawn: {self.base_spawn_interval}ms", True, 'yellow')
        cooldown_text = font.render(f"CD: {self.gun_cooldown}ms", True, 'cyan')
        
        self.display_surface.blit(score_text, (stats_x, stats_y))
        self.display_surface.blit(speed_text, (stats_x, stats_y + 30))
        self.display_surface.blit(spawn_text, (stats_x, stats_y + 60))
        self.display_surface.blit(cooldown_text, (stats_x, stats_y + 90))

        # --- HP Bar Display ---
        bar_width = 200
        bar_height = 20
        bar_x = WINDOW_WIDTH - bar_width - 10
        bar_y = 10
        
        # Calculate current health width
        health_ratio = self.player_health / self.player_max_health
        current_width = int(bar_width * health_ratio)
        
        # HP Bar Background (Black with white border)
        pygame.draw.rect(self.display_surface, 'gray', (bar_x, bar_y, bar_width, bar_height), 2, 5)
        
        # HP Bar Foreground (Health)
        health_color = 'lime' if self.player_health > 1 else 'red'
        pygame.draw.rect(self.display_surface, health_color, (bar_x + 1, bar_y + 1, current_width - 2, bar_height - 2), 0, 5)

        # Player Flash effect when hit
        if not self.is_vulnerable:
            # Creates a red screen flash that fades out
            flash_alpha = 150 - int(150 * (pygame.time.get_ticks() - self.hit_time) / self.vulnerability_duration)
            flash_surf = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT)).convert_alpha()
            flash_surf.fill((255, 0, 0, max(0, flash_alpha)))
            self.display_surface.blit(flash_surf, (0, 0))
            
        # Text Overlay
        hp_text = font.render(f"HP: {self.player_health}/{self.player_max_health}", True, 'white')
        hp_text_rect = hp_text.get_rect(midright=(bar_x + bar_width + 50, bar_y + bar_height // 2))
        self.display_surface.blit(hp_text, hp_text_rect)

    def draw_game_over(self):
        """Draws the game over screen."""
        self.display_surface.fill('black') 

        # Main Title: "GAME OVER"
        title_font = pygame.font.Font(None, 120)
        title_text = title_font.render("GAME OVER", True, 'red')
        title_rect = title_text.get_rect(center = (WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 - 100))
        self.display_surface.blit(title_text, title_rect)
        
        # Score Display
        score_font = pygame.font.Font(None, 64)
        score_text = score_font.render(f"FINAL SCORE: {self.score}", True, 'white')
        score_rect = score_text.get_rect(center = (WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2))
        self.display_surface.blit(score_text, score_rect)
        
        # Call to Action
        cta_font = pygame.font.Font(None, 36)
        cta_text = cta_font.render("Click Anywhere to Return to Menu", True, 'yellow')
        cta_rect = cta_text.get_rect(center = (WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 + 80))
        self.display_surface.blit(cta_text, cta_rect)

    def run(self):
        """The main game loop."""
        while self.running:
            dt = self.clock.tick() / 1000 # Delta time in seconds

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                
                if self.state == MENU:
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        self.menu.handle_input()
                
                elif self.state == GAME_ACTIVE:
                    if event.type == self.enemy_event:
                        # Spawn enemy only when game is active
                        Enemy(
                            choice(self.spawn_positions), 
                            choice(list(self.enemy_frames.values())),
                            (self.all_sprites, self.enemy_sprites), 
                            self.player, 
                            self.collision_sprites,
                            self.current_enemy_speed
                        )
                
                elif self.state == GAME_OVER:
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        self.state = MENU
                        self.menu = Menu(self) # Re-initialize menu to restart music

            # Game State Logic
            if self.state == MENU:
                self.menu.display()

            elif self.state == GAME_ACTIVE:
                # Update
                self.gun_timer()
                self.vulnerability_timer()
                self.input()
                self.all_sprites.update(dt)
                self.bullet_collision()
                self.drop_collision()
                self.player_collision()
                
                # Draw
                self.display_surface.fill('black')
                self.all_sprites.draw(self.player.rect.center)
                self.display_ui()
            
            elif self.state == GAME_OVER:
                self.draw_game_over()

            pygame.display.update()

        pygame.quit()


if __name__ == '__main__':
    game = Game()
    game.run()

==============================================================================================================================================================

Speed Increment on Enemies
    -Starts at self.speed = 5 and increments by +5 every 100 kills

from settings import *
from math import atan2, degrees
from os.path import join 

class Sprite(pygame.sprite.Sprite):
    def __init__(self, pos, surf, groups):
        # size expected as a (width, height) tuple passed from caller
        super().__init__(groups)
        self.image = surf
        self.rect = self.image.get_frect(topleft= pos)
        self.ground = True


class CollisionSprite(pygame.sprite.Sprite):
    def __init__(self, pos, surf, groups):
        # size expected as a (width, height) tuple passed from caller
        super().__init__(groups)
        self.image = surf
        self.rect = self.image.get_frect(topleft = pos)

class Gun(pygame.sprite.Sprite):
    def __init__(self, player, groups):

        # Connection to Player 
        self.player = player    
        self.distance = 140
        self.player_direction = pygame.Vector2(0,1)

        #Sprite For Gun

        super().__init__(groups)
        self.gun_surf = pygame.image.load(join('images','gun','gun.png')).convert_alpha()
        self.image = self.gun_surf
        self.rect = self.image.get_frect(center = self.player.rect.center + self.player_direction * self.distance)

    def get_direction(self):
        mouse_pos = pygame.mouse.get_pos()
        
        # Player is centered on the screen by the camera
        screen_center = pygame.math.Vector2(WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2)
        
        # Calculate the vector from the screen center (player) to the mouse position
        direction_vector = pygame.math.Vector2(mouse_pos) - screen_center
        
        # Get the angle in degrees
        angle = degrees(atan2(direction_vector.y, direction_vector.x))
        return direction_vector.normalize(), angle

    def update(self, dt):
        direction, angle = self.get_direction()
        
        # Rotate the gun image
        self.image = pygame.transform.rotate(self.gun_surf, -angle)
        self.rect = self.image.get_frect(center = self.player.rect.center + direction * self.distance)

        
class Bullet(pygame.sprite.Sprite):
    def __init__(self, pos, direction, groups):
        super().__init__(groups)
        self.image = pygame.Surface((30,30))
        self.image.fill('red')
        self.rect = self.image.get_frect(center = pos)
        
        self.direction = direction
        self.speed = 1000

    def update(self, dt):
        self.rect.center += self.direction * self.speed * dt
        
        # Remove bullet if it goes too far off-screen
        if self.rect.right < -WINDOW_WIDTH or self.rect.left > WINDOW_WIDTH * 2 or \
           self.rect.bottom < -WINDOW_HEIGHT or self.rect.top > WINDOW_HEIGHT * 2:
            self.kill()

class Enemy(pygame.sprite.Sprite):
    # UPDATED: Added 'speed' parameter to the constructor
    def __init__(self, pos, frames, groups, player, collision_sprites, speed):
        super().__init__(groups)
        
        #Animation
        self.frames, self.frame_index = frames, 0
        self.image = self.frames[self.frame_index]
        self.rect = self.image.get_frect(topleft = pos)

        #Movement
        self.player = player
        self.collision_sprites = collision_sprites
        self.hitbox_rect = self.rect.inflate(-90, -90)
        # UPDATED: Use the passed 'speed'
        self.speed = speed
        self.direction = pygame.math.Vector2()

        #Death
        self.death_time = 0
        self.is_dead = False
        
    def update(self, dt):
        if not self.is_dead:
            self.move(dt)
        else:
            self.death_timer()

    def move(self, dt):
        player_pos = pygame.math.Vector2(self.player.rect.center)
        enemy_pos = pygame.math.Vector2(self.rect.center)
        
        # Calculate direction towards player
        self.direction = (player_pos - enemy_pos).normalize() if player_pos != enemy_pos else pygame.math.Vector2()

        # update Rectangel Position (where player will be) + collision
        self.hitbox_rect.x += self.direction.x * self.speed * dt
        self.collisions('horizontal')
        self.hitbox_rect.y += self.direction.y * self.speed * dt
        self.collisions('vertical')
        self.rect.center = self.hitbox_rect.center

    def collisions(self, direction):
        for sprite in self.collision_sprites:
            if sprite.rect.colliderect(self.hitbox_rect):
                if direction == 'horizontal':
                    if self.direction.x > 0: self.hitbox_rect.right = sprite.rect.left
                    if self.direction.x < 0: self.hitbox_rect.left = sprite.rect.right
                else:
                    if self.direction.y > 0: self.hitbox_rect.bottom= sprite.rect.top
                    if self.direction.y < 0: self.hitbox_rect.top = sprite.rect.bottom

    def destroy(self):
        # Set death flag and timer
        self.is_dead = True 
        self.death_time = pygame.time.get_ticks()
        
        # Change Image to a mask/explosion effect
        surf = pygame.mask.from_surface(self.frames[0]).to_surface()
        surf.set_colorkey('black')
        self.image = surf

    def death_timer(self):
        # Enemy is dead, fade out and remove
        if pygame.time.get_ticks() - self.death_time > 100:
            self.kill()

class MapSprite(Sprite):
    def __init__(self, pos, surf, groups):
        super().__init__(pos, surf, groups)
        self.ground = False # This sprite is part of the level geometry
==============================================================================================================================================================
